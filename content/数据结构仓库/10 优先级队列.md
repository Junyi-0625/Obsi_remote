# 10.1 定义
- 操作对象：**全局极值**
	- 不再需要像 BBST 那样维护全序，仅需维护偏序
- 数据项之间的大小关系可以称为优先级，始终访问优先级最高的数据项的数据结构称为**优先级队列**
	- 仿照词典，将数据项称为**词条**，对应优先级的属性称为**关键码**
![](Picture/Pasted%20image%2020241207164525.png)
# 10.2 堆
通过“堆”维护偏序关系
## 10.2.1 完全二叉堆
- 通过完全二叉树实现
	- 此时**节点**与**词条**一一对应
- 大顶堆与小顶堆：
	- **堆序性**：堆顶外每个节点优先级都不高（低）于其父节点，前（后）者称为大（小）顶堆
	- 通过颠倒优先级关系，可以将大小顶堆相互转化
- 高度 $h = \lfloor \log_2(n) \rfloor = O(\log n)$。 
- 完全二叉树可以通过向量实现：
![](Picture/Pasted%20image%2020241207165514.png)
- 仅需要 $O(n)$ 的空间
- 节点 $v$ 的秩记为 $i(v)$，则：
	- $i(lchild(v)) = 2 * i(v) + 1$
	- $i(rchild(v)) = 2 * i(v) + 2$
	- $i(parent(v)) = \lfloor (i(v) - 1)/2 \rfloor = \lceil i(v)/2 \rceil - 1$
## 10.2.2 插入 insert()
- 节点直接插入向量末尾，不断与父亲比较，直到满足堆序性
	- 每比较一次，节点在堆中的高度上升一层，故称为“**上滤**”**percolateUp**
- 最坏情况：一直上滤到堆顶，不超过全堆高度 $\lfloor \log_2(n) \rfloor$，即 $O(\log n)$
	- 平均来看，关键码均匀独立分布时，插入的期望时间为常数，即 $O(1)$
![](Picture/Pasted%20image%2020241207173111.png)
- 示例如下：
![](Picture/Pasted%20image%2020241207173152.png)
## 10.2.3 删除 delMax()
- 待删除节点总位于堆顶，但直接取出会破坏堆结构
	- 将末尾节点转移至堆顶，并调整使其满足堆序性
- 若末尾节点在堆顶不满足堆序性，则不断将其与两个孩子中的较大者交换位置，直到堆序性恢复
	- 每次交换必将下降一层，即“**下滤**”**percolateDown**
	- 最多下降至堆底，时间复杂度为$O(\log n)$
- 示例如下：
![](Picture/Pasted%20image%2020241207200209.png)
## 10.2.4 Floyd 建堆
- 建堆：将给定的一组词条组成一个堆
- 蛮力算法：
	- 逐一插入词条，耗时$O(\log 1 + \log 2 + \cdots + \log n) = O(\log n!) = O(n \log n)$
	- 等效于自顶向下、从左至右对二叉树中的每个节点做一次上滤，即“自上而下的上滤”
- Floyd 算法
	- 对于下图，若 $r_0$ 和 $r_1$ 已满足堆序性，则仅需要对 $p$ 做一次下滤即可将二叉树转换成堆，即“自下而上的下滤”
![|340](Picture/Pasted%20image%2020241207204312.png)
- 示例如下：
- 时间复杂度分析
	- 等效与对所有节点各做一次下滤，下滤所需时间线性正比于其高度
	- 运行时间仅为 $O(n)$
	- ![](Picture/Pasted%20image%2020241207204848.png)
	- 蛮力算法太多时间消耗于深度大的节点
## 10.2.5 堆排序
- 就地算法
	- 不断交换堆顶与末尾元素，随后进行下滤，并减治
![|500](Picture/Pasted%20image%2020241207232022.png)
- 复杂度
	- 每个 x 的下滤时间不超过 $O(\log n)$，总体排序不超过 $O(n\log n)$
	- 需要加上建堆时间，即便使用蛮力算法，整个算法也不超过 $O(n \log n)$
- 示例如下：
## 10.2.6 多叉堆
- 对于 Prim 和 Dijsktra，统一采用 PFS 来选择优先级最高者
	- $n$ 为顶点数量，$e$ 为边数量
	- 暴力算法：随机选择一个顶点，遍历邻边、找到优先级最高的然后更新关联顶点的优先级，选择优先级最高的顶点加入最小支撑树/最短路径树，并重复这个过程
		- 采用邻接表实现时，更新优先级需要 $O(n + e)$，选择优先级最高者需要 $O(n^2)$
	- 采用优先级队列：总体耗时 $O((n+e)\log n)$，仅适合稀疏图
		- 更新顶点优先级耗时 $O(n\log n)$
		- 选择优先级最高的顶点耗时 $O(e \log n)$
- 使用多叉堆作为优先级队列
	- 仍然基于向量实现
	- 堆高降低，上滤成本必然下降
		- 下滤成本则跟堆高与孩子数量均相关，即$d \cdot \log_dn$，在 d > 4 时成本增加
	- PFS 的总体耗时优化为 $O((n\cdot d + e)\log_dn)$
		- $d \approx e/n+2$ 时总体性能达到最优
# 10.3 锦标赛树
## 10.3.1 胜者树
- 完全二叉树，其中待排序节点作为叶子节点
	- 内部节点为其左右孩子比较后的胜者
	- 树根为冠军
- 示例如下：
	- ![](Picture/Pasted%20image%2020241208101628.png)
	- ![](Picture/Snipaste_2024-12-08_10-16-43.png)
- 时间复杂度
	- 构造：每个元素仅需比较一次，$O(n)$
	- 每次更新：将胜者设置为 $\inf$，再从叶子节点上溯至根节点，$O(\log n)$
		- 总体为 $O(n\log n)$
## 10.3.2 败者树
- 胜者树的每次更新都需要先通过父亲节点再找到兄弟节点进行比较，常系数较大
- 通过败者树进行改进：
	- 内部节点记录败者
	- 增设根节点的“父节点”，记录冠军
	- “胜者继续比较，败者留下姓名”
- 示例如下：
	- ![](Picture/Pasted%20image%2020241208102654.png)
	- ![](Picture/Pasted%20image%2020241208102712.png)
- 时间复杂度
	- 败者树在更新后，叶子节点仅需与其父节点比较，省去了查询兄弟节点的步骤，常系数较小
# 10.4 左式堆
## 10.4.1 堆合并
- 给定两个堆，如何合并？
	- 逐一删除再插入
	- 对所有词条进行 Floyd 建堆
- 实际上可以利用两个堆自身已有的偏序性
	- 为了使堆合并时操作的节点数量足够少，堆需要保持“不平衡”
## 10.4.2 左式堆
- 一种优先级队列的实现方式，保证在堆合并中调整的节点数量不超过 $O(\log n)$
- 空节点路径长度 npl(x)
	- 若 x 为外部节点，则 npl(x) = 0
	- 若 x 为内部节点，则 npl(x) = 1 + min{npl(lc(x)), npl(rc(x))}，取决于左、右孩子 npl 值中的较小者
	- 等效于 x 到外部节点的最近距离，也等于以 x 为根的最大满子树高度
- 左式堆的左倾性：npl(lc(x)) ≥ npl(rc(x))
	- 对于任意节点：npl(x) = 1 + npl(rc(x))，即 npl 仅取决于右孩子
	- **“左孩子的npl值不小于右孩子”并不意味着“左孩子的高度必不小于右孩子”**
- 最右侧通路 rpath(x)：沿右侧分支到达空节点的通路
	- 对于根节点，npl(r) = |rpath(r)| = d
	- 故左式堆至少包含 $2^{d + 1}  - 1$ 个节点，同理在包含 n 个节点的左式堆中，最右侧通路不长于 $\lfloor \log_2(n + 1) - 1 \rfloor = O(\log n)$
## 10.4.3 合并 merge()
- 假设 a ≥ b，则不断用 b 替代 a 的右孩子
	- 若左右孩子的 npl 失序，则交换
- 示例如下：
- 时间复杂度
	- $O(\log(max(n, m)))$
- 基于合并的删除
	- 对根节点的左右孩子进行 merge()
- 基于合并的插入
	- 对单节点堆 merge()