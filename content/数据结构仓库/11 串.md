# 11.2 KMP 算法
- 思想：避免文本串中指针的回退，利用已知信息使模式串尽可能右移
![](Picture/Pasted%20image%2020241203164708.png)
- 代码实现：i 永不后退
- ![](Picture/Pasted%20image%2020241203164619.png)
	- 如果匹配，则 i 与 j 均自增，文本串、模式串指针均右移
	- 若失配，则 i 不动，j = next\[j\]，模式串右移
## next\[\]
![](Picture/Pasted%20image%2020241203164402.png)
- next\[0\] = -1，当 T\[i\] != P\[0\]，说明文本串指针应当向右移，代码进入 else 条件，j = -1，下一次循环中进入 if 条件，i++、j++
- next\[j\] = t，t 为 P\[0, j) 中，真前缀和真后缀匹配的最大长度
### 递推计算 next\[j + 1\]
- 已知 next\[0, j\]，当 P\[j\] = P\[next\[j\]\]，next\[j + 1\] = next\[j\] + 1
	- 若 P\[j\] != P\[next\[j\]\]，则比较 P\[j\] 与 P\[next\[next\[j\]\]\]、P\[next\[next\[next\[j\]\]\]\]...
		- 直到相等，此时 next\[j + 1\] = next\[...next\[j\]...\] + 1
- next\[\] 表的构造算法实现如下：构造过程等效于模式串的自我匹配，故与 KMP 算法的形式基本相同
- ![](Picture/Pasted%20image%2020241205143552.png)
## 改进 next\[\]
- next\[\] 仅考虑了真前后缀匹配提供的信息，未考虑当前字符匹配失败提供的信息
	- 对于上述模式串，若在 P\[4\] = 'C' 处匹配失败，则会跳转到 P\[next\[4\]\] = P\[0\] = 'C' 处再次比较，此时仍会失败
	- 可以减少失败后的模式串移动次数
- t 为 P\[0, j) 中，真前缀和真后缀匹配的最大长度，且 P\[j\] != P\[t\] 时，next\[j\] = t
	- 若 P\[j\] = P\[t\]，则 next\[j\] = next\[t\]
![](Picture/Pasted%20image%2020241204132421.png)
- 改进 next\[\] 的构造算法实现如下：
- ![](Picture/Pasted%20image%2020241205143859.png)
### 例题
已知模式串为 'ABCCOAEOTABCP'，在使用改进版 next\[\] 表的 KMP 算法时，模式串单次右移的最大长度为<u>   11   </u>.
![](Picture/Pasted%20image%2020241204135124.png)
右移长度就是j - next\[j\]，故最大为11 - 0 = 11.
## KMP 算法的时间复杂度——$O(n + m)$
假设文本串规模为 n，模式串规模为 m，简单来看，KMP 算法中文本串内的每个字符仍有可能进行 m 次匹配，那么 KMP 算法的时间复杂度是否相对暴力算法的 $O(nm)$ 没有任何提升？

取 k = 2 * i - j，则匹配时，i++、j++，k 增大；失配时，i 不变、j 至少减小 1，k 仍会增大。故 k 在匹配过程中单调递增，初始时 k = 0，结束时 k = 2 * i - j ≤ 2(n - 1) - 1 = 2n - 1，故 while() 总共消耗的时间不超过 $O(n)$。

实际上，在整个算法的执行过程中，i 始终等于匹配的次数，而 i - j 始终不小于失配的次数。前者较容易理解，仅匹配时才有 i++；后者则是仅在失配时增大，j = next\[j\] 会至少减少 1，故 i - j 始终是失配次数的上界。

类似的，由于 next\[\] 表的构造算法与 KMP 算法没有本质区别，故 next\[\] 的构造也仅需要 $O(m)$ 时间，故 KMP 算法的整体运行时间为 $O(n + m)$。
# 11.3 BM 算法：以终为始
在模式串和文本串对齐的位置，**“从右向左”** 逐一比对各字符。BM 算法过程如下：
![](Picture/Pasted%20image%2020241205145108.png)
- 从右向左比对，失配或 j = -1 时退出 while()
	- 若 j < 0，则完全匹配
	- 否则，根据 BC 表或 GS 表右移模式串
## 坏字符策略
示例如下：
![|500](Picture/Pasted%20image%2020241205205622.png)
在文本串字符 'x' 失配时，需要通过查询 bc\[\]，找到模式串最靠右的字符 'x'，并右移模式串使之与失配字符对齐。
### bc\[\] 的构造
bc\[\] 中存储了字符集内的每个字符在模式串中的最大的秩，示例如下：
![](Picture/Pasted%20image%2020241205200436.png)
只需要从左向右遍历模式串，不断用当前字符的秩更新 bc\[\] 中的对应项，最终 bc\[\] 中会记录下每个字符最靠右者的秩。
![](Picture/Pasted%20image%2020241205200836.png)
由于和画布上各处最终的颜色由画家的最后一笔决定相似，这类算法也称为**画家算法**。

假设文本串在字符 'x' 处失配，则将 P\[bc\['x'\]\] 与 'x' 对齐，随后再次从右向左查找，并不断循环。

换而言之，文本串与模式串在 rank = i 处对齐，模式串在 rank = j 时失配，则模式串需要右移 j - bc\[T\[i + j\]\] 个单位。
### 坏字符策略的时间复杂度
记 $\Sigma$ 为字符集，n 为文本串长度，m 为模式串长度，则 $|\Sigma|$ 为字符集大小，同时易知，bc\[\] 构造的时间复杂度不超过 $O(|\Sigma| + m)$。

BM 算法本身比对的时间复杂度与输入非常相关。最好情况下，每次只需比对 1 次就将模式串整体右移，此时运行时间不超过 $O(n / m)$。最坏情况下，每次模式串需要完整地扫描一遍才向右移动 1 个字符，此时运行时间为 $O(n \times m)$，如下图所示。
![](Picture/Pasted%20image%2020241205204050.png)
## 好后缀策略
坏字符仅利用了最后一次失配的信息，没有利用此前成功比对的信息。如上图 11.3，若已有大量 '0' 的成功匹配，则应该将 P\[0\] 对准 T 中未必对的首个字符，则算法的运行时间将会降低至 $O(n)$。示例如下：
![|500](Picture/Pasted%20image%2020241205210334.png)
1. 初始时刻，从右向左比对，'也' 与 '静' 失配，在模式串中找到最靠右的 '静'，并移动模式串使之对齐；
2. 再从右向左比对，'静也' 匹配，'故' 与 '曰' 失配，在模式串中找到最靠右的 '静也'，并移动模式串使之对齐；
3. 再从右向左比对，发现完全匹配，算法结束。
### gs\[\] 的构造
gs\[\] 存储了每个字符失配时，对齐位置需要右移的长度。
![](Picture/Pasted%20image%2020241205222535.png)
直接构造 gs\[\] 较为困难，可以通过引入 ss\[\] 来构造 gs\[\]。
![](Picture/Pasted%20image%2020241206163442.png)
ss\[\] 表示 P\[\] **前缀中的后缀**与 P\[\]**本身的后缀**匹配的最大长度。
# 11.4 Karp-Rabin 算法
