# 11.2 KMP算法
- 思想：避免文本串中指针的回退，利用已知信息使模式串尽可能右移
![](Picture/Pasted%20image%2020241203164708.png)
- 代码实现：i永不后退
- ![](Picture/Pasted%20image%2020241203164619.png)
	- 如果匹配，则 i 与 j 均自增，文本串、模式串指针均右移
	- 若失配，则 i 不动，j = next\[j\]，模式串右移
## next\[\]
![](Picture/Pasted%20image%2020241203164402.png)
- next\[0\] = -1，当 T\[i\] != P\[0\]，说明文本串指针应当向右移，代码进入 else 条件，j = -1，下一次循环中进入 if 条件，i++、j++
- next\[j\] = t，t 为 P\[0, j) 中，真前缀和真后缀匹配的最大长度
### 递推计算next\[j + 1\]
- 已知 next\[0, j\]，当 P\[j\] = P\[next\[j\]\]，next\[j + 1\] = next\[j\] + 1
	- 若 P\[j\] != P\[next\[j\]\]，则比较 P\[j\] 与 P\[next\[next\[j\]\]\]、P\[next\[next\[next\[j\]\]\]\]...
		- 直到相等，此时 next\[j + 1\] = next\[...next\[j\]...\] + 1
- next\[\] 表的构造算法实现如下：构造过程等效于模式串的自我匹配，故与 KMP 算法的形式基本相同
- ![](Picture/Pasted%20image%2020241205143552.png)
## 改进next\[\]
- next\[\] 仅考虑了真前后缀匹配提供的信息，未考虑当前字符匹配失败提供的信息
	- 对于上述模式串，若在 P\[4\] \== 'C' 处匹配失败，则会跳转到 P\[next\[4\]\] \== P\[0\] \== 'C' 处再次比较，此时仍会失败
	- 可以减少失败后的模式串移动次数
- t 为 P\[0, j) 中，真前缀和真后缀匹配的最大长度，且 P\[j\] != P\[t\] 时，next\[j\] = t
	- 若 P\[j\] = P\[t\]，则 next\[j\] = next\[t\]
![](Picture/Pasted%20image%2020241204132421.png)
- 改进 next\[\] 的构造算法实现如下：
- ![](Picture/Pasted%20image%2020241205143859.png)
### 例题
已知模式串为 'ABCCOAEOTABCP'，在使用改进版 next\[\] 表的 KMP 算法时，模式串单次右移的最大长度为<u>   11   </u>.
![](Picture/Pasted%20image%2020241204135124.png)
右移长度就是j - next\[j\]，故最大为11 - 0 = 11.
## KMP 算法的时间复杂度——$O(n + m)$
假设文本串规模为 n，模式串规模为 m，简单来看，KMP 算法中文本串内的每个字符仍有可能进行 m 次匹配，那么 KMP 算法的时间复杂度是否相对暴力算法的 $O(nm)$ 没有任何提升？

取 k = 2 * i - j，则匹配时，i++、j++，k 增大；失配时，i 不变、j 至少减小 1，k 仍会增大。故 k 在匹配过程中单调递增，初始时 k = 0，结束时 k = 2 * i - j ≤ 2(n - 1) - 1 = 2n - 1，故 while() 总共消耗的时间不超过 $O(n)$。

实际上，在整个算法的执行过程中，i 始终等于匹配的次数，而 i - j 始终不小于失配的次数。前者较容易理解，仅匹配时才有 i++；后者则是仅在失配时增大，j = next\[j\] 会至少减少 1，故 i - j 始终是失配次数的上界。

类似的，由于 next\[\] 表的构造算法与 KMP 算法没有本质区别，故 next\[\] 的构造也仅需要 $O(m)$ 时间，故 KMP 算法的整体运行时间为 $O(n + m)$。
# 11.3 BM算法：以终为始
在模式串和文本串对齐的位置，**“从右向左”** 逐一比对各字符。