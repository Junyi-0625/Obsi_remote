## 1.1.1 定义
当输入数据规模为$n$时，算法执行时间的变化趋势可以表示为一个关于$n$的函数，即时间复杂度$T(n)$。当$n \rightarrow \infty$时，有三种情况：
1. $T(n) \leq C \cdot f(n)$，且$C>0$为常数，则$T(n) = O(f(n))$；
2. $C_1 \cdot h(n) \leq T(n) \leq C_2 \cdot h(n)$，且$C_2 > C_1 > 0$为常数，则$T(n) = \Theta(h(n))$；
3. $C \cdot g(n) \leq T(n)$，且$C > 0$为常数，则$T(n) = \Omega(g(n))$。

这种注重时间复杂度总体变化趋势的，用$O(\cdot)$、$\Theta(\cdot)$和$\Omega(\cdot)$表示的记号称为**渐进复杂度**。

其中，$f(n)$为$T(n)$的渐进上界，$g(n)$为$T(n)$的渐进下界，$h(n)$为$T(n)$的确界。

在“$n$充分大”和“忽略常数”的前提下，易知：
$O(f(n)) = O(c \cdot f(n)), c > 0$，且$O(n^a + n^b) = O(n^a), a > b > 0$。
## 1.1.2 性质
**一、不可交换**

例：设$n^3 = O(n^4)$，$n^2 = O(n^4)$，但$n^3 = O(n^4) = n^2$并不成立。即复杂度记号中的“=”两边不可交换。有以下三个性质：
1. **等式左边包含的信息不少于右边**（最基本的性质）；
2. 复杂度记号本身损失了常数信息，故只能出现在等式右侧。若出现在左侧，则右侧也一定是复杂度记号；
3. 从$\Theta(\cdot)$转化为$O(\cdot)$或者$\Omega(\cdot)$会损失一侧的信息，故连等式中$\Theta(\cdot)$只会出现在等式左侧。只有一种情况例外，即$O(1) = \Theta(1)$。
如，$2n^2 = \Theta(n^2) = O(n^3) = O(n^4)$正确。

**二、不是所有算法都可以用$\Theta(\cdot)$衡量**

例：$T(n) = n (\sin(\frac{n \pi}{2}) + 1)$不存在与其同阶的无穷大量。所以我们更多的使用表示上界的$O(\cdot)$来描述增长速度。

**三、只有$\Theta(\cdot)$才能进行比较**

例：已知算法A的时间复杂度为$O(n)$，算法B的时间复杂度为$O(n^2)$，是否能认为算法A的时间复杂度一定低于算法B？

无从得知，$O(\cdot)$仅表示上界，故算法B的时间复杂度同时也可能是$O(n)$甚至$O(1)$，并不一定高于算法A。

类似的，$\Omega(\cdot)$也不可比较，只有表示同阶无穷大量的$\Theta(\cdot)$有比较的意义。

**四、不满足除法，仅满足单向乘法**

$O(f(n)) / O(g(n)) = O(f(n) / g(n))$不成立。

$O(f(n)) \cdot O(g(n)) = O(f(n) \cdot g(n))$成立，但反过来则不成立。

复杂度记号包裹的范围越大，就会损失越多的信息。

**五、复杂度记号与情况无关**

尽管$O(\cdot)$和$\Omega(\cdot)$表示上下界，但并不代表“最坏情况”和“最好情况”。

**情况**表示和输入数据规模$n$无关的数据特征。比如使用起泡排序`bubblesort1A()`进行排序。
```C++
void bubblesort1A(int A[], int n){
	bool sorted = false;
	while(!sorted){
		sorted = true;
		for(int i = 1; i < n; i++){
			if(A[i - 1] > A[i]){
				swap(A[i - 1], A[i]); //交换逆序的A[i - 1]和A[i]
				sorted = false;
			}
		}
		n--; //每扫描完一趟，末尾元素必然就位
	}
}
```
![[Pasted image 20240628223046.png]]
除了问题规模$n$之外，这$n$个整数自身的排列特征也会影响排序的时间。若所有元素已按序排列，则内循环仅需要一趟便可终止算法，即$T(n) = n$。若$n$个元素完全逆序，即输入序列为{n, n - 1, ..., 1}，则每个元素均需要进行$n - 1$次交换，可认为$T(n) = n(n - 1)$。

对于同样的$n$，不同情况的输入数据会得到不同的$T(n)$，即$T(n)$从一个准确的值变成了一个范围，其下限对应最好情况，上限对应最坏情况。若$T(n)$在最好和最坏情况下为$g(n)$和$h(n)$，则可以对$g(n)$和$h(n)$分别做复杂度分析，这一过程中三种记号均可以使用。
![[Pasted image 20240629095322.png]]
然而，不同的记号表达的侧重点不同。如上图所示，当我们使用$O(\cdot)$描述最好情况$g(n)$时，可以体现出“最好”究竟有多好，而使用$\Omega(\cdot)$则无法体现这一点。沿用上述起泡排序的示例，最好情况下$T(n) = n$，$O(n)$表示最好情况的时间复杂度不会比$n$更高，即至少能低到$n$量级，而$\Omega(n)$表示不会比$n$更低，却并不能说明具体有多低，比如$n$和$n^2$均可以表示为$\Omega(n)$。相应的，$\Omega(\cdot)$才能体现“最坏”到底有多坏。

故无法用$\Theta(\cdot)$准确描述时，常用$O(\cdot)$描述最好情况，用$\Omega(\cdot)$描述最坏情况。
## 1.1.3 应用：分析给定函数的时间复杂度
（24真题）分析给定函数`F(int n)`的时间复杂度，函数的定义如下：
```cpp
void F(int n) {  // 假定字宽足够,运算不会溢出，且每次只需常数时间
    for (int i = 1, j = 1; i < n; j <<= 1) {
        i <<= j;
    }
}
```
### 分析每个变量的变化
- $i$和$j$都初始化为1。
- 在每次循环中，$j$左移1位，即$j = j * 2$。
- 在每次循环中，$i$左移$j$位，即 $i = i * 2^j$。
#### $j$的增长
每次循环，$j$变为原来的2倍：
- 第1次循环：$j = 2$
- 第2次循环：$j = 4$
- 第3次循环：$j = 8$
- ...
- 第$k$次循环后，$j$将是$2^k$。
#### $i$的增长
每次循环，$i$左移$j$位，使得$i$变为$i * 2^j$：
- 初始时：$i = 1$
- 第1次循环：$i = 1 << 2 = 2^2 = 4$
- 第2次循环：$i = 4 << 4 = 4 * 2^4 = 4 * 16 = 64$
- 第3次循环：$i = 64 << 8 = 64 * 2^8 = 64 * 256 = 16384$
- ...
- 第$k$次循环后，$i$将是$i = 2^{2^k}$。
### 循环终止条件
循环继续执行直到$i >= n$，此时我们需要找到$k$，使得$i$达到或超过$n$，即：$2^{2^k} \geq n$。

两边同时取对数，有：$2^k \geq \log_2(n)$。

再取对数：$k \geq \log_2(\log_2(n))$。
### 时间复杂度
循环运行的次数是$k = O(\log_2(\log_2(n)))$，且由于每次循环中的操作（左移和比较）都花费常数时间，因此整个函数`F(int n)`的时间复杂度是：$O(\log(\log(n)))$。

## 1.1.4 应用：比较不同时间复杂度的大小（层次级别）
### 多重对数函数$lg^{*}n$
前置知识：$\lg^{(i)}n$表示连续对$n$应用$i$次对数函数，$\lg^{i}n=(\lg n)^i$表示$n$的对数的$i$次幂。

则定义$\lg^{*}n = min \{ i \geq 0 : \lg^{(i)}n \leq 1\}$，即对$n$连续应用对数函数，使其$\leq 1$的次数。其增长速度极其缓慢：

$$
\begin{align}
\lg^{*}2 & = 1 \\
\lg^{*}4 & = 2 \\
\lg^{*}16 & = 3 \\
\lg^{*}65535 & = \lg^{*}(2^{16}) = 4 \\
\lg^{*}(2^{65535}) & = 5
\end{align}
$$
显而易见，很少存在一个使$lg^{*}n > 5$的输入规模。
### 斯特林近似公式
对于阶乘$n!$，一个很明显的弱上界是$n^{n}$，即$n! \leq n^{n}$。而斯特林近似公式给出：
$$
n! = \sqrt{2 \pi n} \left(\frac{n}{e}\right)^{n} \left(1 + \Theta\left(\frac{1}{n}\right)\right) \approx \sqrt{2 \pi n}\left(\frac{n}{e}\right)^{n}
$$
---
**简单应用**：证明$lg(n!) = \Theta(nlgn)$
证明$\Theta(\cdot)$，需要证明$\Omega(\cdot) = O(\cdot)$，即上下界相等。上界较易证明：
$$
\lg(n!) < \lg(n^{n}) = n\lg n
$$
但是下界不好得到，转而使用斯特林近似公式：
$$
\begin{align}
\lg(n!) & = \lg\sqrt{2 \pi n} + n\lg\left(\frac{n}{e}\right) + \lg\left(1 + \Theta\left(\frac{1}{n}\right)\right) \\
& = \frac{1}{2}\lg(2 \pi n) + n(\lg n - \lg e) + \lg\left(1 + \frac{c}{n}\right) , c\text{为常数}\\
& = \Theta(\lg n) + \Theta(n\lg n) + \lg(n + c) - \lg n \\
& = \Theta(n\lg n)
\end{align}
$$
### PPT第40页的证明
![[Pasted image 20240731213127.png|400]]
#### (1) $\text{fib(n)} = O(2^n)$正确
斐波那契数的定义为：$\text{fib(0) = 0, fib(1) = 1, fib(n) = fib(n - 1) + fib(n - 2), n} \geq 2$。

假设$\text{fib(n)} = O(2^n)$，则存在常数$C$，使$\text{fib(n)} \leq C \cdot 2^n$。

首先，对于$n = 0$，$\text{fib(0)} = 0 \leq 1 \cdot 2^0 = 1$。对于$n = 1$，$\text{fib(1)} = 1 \leq 1 \cdot 2^1 = 2$，可以考虑使用数学归纳法。

假设对于所有$k \leq n$，有$\text{fib(k)} \leq 2^k$，则需要证明对于$\text{k = n + 1，fib(n + 1)} \leq 2^{n + 1}$。

由假设可以得知，$\text{fib(n)} \leq 2^n$，$\text{fib(n - 1)} \leq 2^{n - 1}$，则：
$$
\text{fib(n + 1) = fib(n) + fib(n - 1)} \leq 2^n + 2^{n - 1} \leq 2^{n + 1}
$$
故可以得知，对于$n \geq 0$，有$\text{fib(n)} \leq 2^n$，即$\text{fib(n)} = O(2^n)$。
#### (2) $\text{12n + 5} = O(n\log n)$正确
很明显，在$n$足够大时，$\log n >> 12$，故$n\log n > 12n$，即$\text{12n + 5} = O(n\log n)$。
#### (3) $\log^2(n^{1024} - 2n^6 + 101) = O(?)$
左边等式中，括号内可以等效为$n^{1024}$，则等式左边可以化为：
$$
\log^2(n^{1024}) = (\log n^{1024})^2 = 1024^2\log^2n = O(\log^2n)
$$
#### (4) $\log^dn = O(n^c), \forall c > 0, d > 1$正确
根据洛必达法则：
$$
\lim_{n \rightarrow \infty} \frac{\log^dn}{n^c} = \lim_{n \rightarrow \infty} \frac{d \log^{d - 1}n}{c n^c} = \dots = \lim_{n \rightarrow \infty} \frac{d(d - 1) \cdots 1}{c (c - 1) \cdots (c - d + 1)n^c} = 0
$$
故$n$足够大时，$\log^dn < n^c$，即$\log^dn = O(n^c)$。
#### (5) $\log^{1.001}n = O(\log(n^{1001}))$错误
根据洛必达法则：
$$
\lim_{n \rightarrow \infty} \frac{\log^{1.001}n}{1001\log n} = \lim_{n \rightarrow \infty} \frac{\frac{1.001\log^{0.001}n}{n}}{\frac{1001}{n}} = \lim_{n \rightarrow \infty} \frac{\log^{0.001}n}{1000} = \infty
$$
故$n$足够大时，$\log^{1.001}n > \log(n^{1001})$，即$\log^{1.001}n = \Omega(\log(n^{1001}))$。

从另一个角度理解，$\log(n^{1001}) = 1001 \log n$是关于$\log n$的线性函数，$\log^{1.001}n$是关于$\log n$的幂函数，增长速度略快于线性，故$\log^{1.001}n = O(\log(n^{1001}))$错误。
#### (6) $(n^2 + 1) / (2n + 3) = O(n)$正确
当$n$足够大时，$(n^2 + 1)/(2n + 3) \approx n / 2 = O(n)$。
#### (7) $n^{2013} = O(n!)$正确
当$n$足够大时，$n! = 1 \cdot 2 \cdots (n - 1) \cdot n > \underbrace{2 \cdot 2 \cdots 2}_{\text{n个}} = 2^n > n^c, \forall c > 0$，故$n^{2013} = O(n!)$。
#### (8) $n! = O(n^{2019})$错误
同(7)。
#### (9) $2^n = O(n!)$正确
同(7)。
### 算法导论思考题3-3
![[Pasted image 20240806220222.png]]
先按照基本层次级别进行划分：
> [!NOTE] 基本层次级别
> 常数：$1$
> 多重对数函数：$\lg^*n$，$\lg^*(\lg n)$
> > $\lg^*(\lg n) = \lg^*n - 1$
> 
> 对数函数：$\ln n$，$\lg^2 n$
> 幂函数：$n^2$，$n^3$，$n$
> 指数函数：$\left(\frac{3}{2}\right)^n$，$\text{e}^n$，$2^n$
> 阶乘：$n!$，$(n+1)!$
> 对数函数的对数函数：$2^{2^n}$，$2^{2^{n+1}}$
> > 如何比较$2^{2^n}$和$(n+1)!$——对两边同时取复合对数$\lg\lg(\cdot)$
> > $\lg \lg (2^{2^n}) = \lg 2^n = n$，$\lg \lg (n+1)! < \lg \lg (n+1)^{n+1} = \lg [(n + 1) \lg (n + 1)] = \lg(n + 1) + \lg \lg(n + 1) < 2 \lg(n + 1)$
> > 当$n$足够大时，$n > 2 \lg(n + 1)$，且复合对数函数$\lg \lg (x)$单调递增，故$2^{2^n} > (n + 1)!$

