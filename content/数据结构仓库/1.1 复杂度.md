## 1.1.1 定义
当输入数据规模为$n$时，算法执行时间的变化趋势可以表示为一个关于$n$的函数，即时间复杂度$T(n)$。当$n \rightarrow \infty$时，有三种情况：
1. $T(n) \leq C \cdot f(n)$，且$C>0$为常数，则$T(n) = O(f(n))$；
2. $C_1 \cdot h(n) \leq T(n) \leq C_2 \cdot h(n)$，且$C_2 > C_1 > 0$为常数，则$T(n) = \Theta(h(n))$；
3. $C \cdot g(n) \leq T(n)$，且$C > 0$为常数，则$T(n) = \Omega(g(n))$。

这种注重时间复杂度总体变化趋势的，用$O(\cdot)$、$\Theta(\cdot)$和$\Omega(\cdot)$表示的记号称为**渐进复杂度**。

其中，$f(n)$为$T(n)$的渐进上界，$g(n)$为$T(n)$的渐进下界，$h(n)$为$T(n)$的确界。

在“$n$充分大”和“忽略常数”的前提下，易知：
$O(f(n)) = O(c \cdot f(n)), c > 0$，且$O(n^a + n^b) = O(n^a), a > b > 0$。
## 1.1.2 性质
**一、不可交换**

例：设$n^3 = O(n^4)$，$n^2 = O(n^4)$，但$n^3 = O(n^4) = n^2$并不成立。即复杂度记号中的“=”两边不可交换。有以下三个性质：
1. **等式左边包含的信息不少于右边**（最基本的性质）；
2. 复杂度记号本身损失了常数信息，故只能出现在等式右侧。若出现在左侧，则右侧也一定是复杂度记号；
3. 从$\Theta(\cdot)$转化为$O(\cdot)$或者$\Omega(\cdot)$会损失一侧的信息，故连等式中$\Theta(\cdot)$只会出现在等式左侧。只有一种情况例外，即$O(1) = \Theta(1)$。
如，$2n^2 = \Theta(n^2) = O(n^3) = O(n^4)$正确。

**二、不是所有算法都可以用$\Theta(\cdot)$衡量**

例：$T(n) = n (\sin(\frac{n \pi}{2}) + 1)$不存在与其同阶的无穷大量。所以我们更多的使用表示上界的$O(\cdot)$来描述增长速度。

**三、只有$\Theta(\cdot)$才能进行比较**

例：已知算法A的时间复杂度为$O(n)$，算法B的时间复杂度为$O(n^2)$，是否能认为算法A的时间复杂度一定低于算法B？

无从得知，$O(\cdot)$仅表示上界，故算法B的时间复杂度同时也可能是$O(n)$甚至$O(1)$，并不一定高于算法A。

类似的，$\Omega(\cdot)$也不可比较，只有表示同阶无穷大量的$\Theta(\cdot)$有比较的意义。

**四、不满足除法，仅满足单向乘法**

$O(f(n)) / O(g(n)) = O(f(n) / g(n))$不成立。

$O(f(n)) \cdot O(g(n)) = O(f(n) \cdot g(n))$成立，但反过来则不成立。

复杂度记号包裹的范围越大，就会损失越多的信息。

**五、复杂度记号与情况无关**

尽管$O(\cdot)$和$\Omega(\cdot)$表示上下界，但并不代表“最坏情况”和“最好情况”。

**情况**表示和输入数据规模$n$无关的数据特征。比如使用起泡排序`bubblesort1A()`进行排序。
```cpp
void bubblesort1A(int A[], int n){
	bool sorted = false;
	while(!sorted){
		sorted = true;
		for(int i = 1; i < n; i++){
			if(A[i - 1] > A[i]){
				swap(A[i - 1], A[i]); // 交换逆序的A[i - 1]和A[i]
				sorted = false;
			}
		}
		n--; // 每扫描完一趟，末尾元素必然就位
	}
}
```
![[Pasted image 20240628223046.png]]
除了问题规模$n$之外，这$n$个整数自身的排列特征也会影响排序的时间。若所有元素已按序排列，则内循环仅需要一趟便可终止算法，即$T(n) = n$。若$n$个元素完全逆序，即输入序列为{n, n - 1, ..., 1}，则每个元素均需要进行$n - 1$次交换，可认为$T(n) = n(n - 1)$。

对于同样的$n$，不同情况的输入数据会得到不同的$T(n)$，即$T(n)$从一个准确的值变成了一个范围，其下限对应最好情况，上限对应最坏情况。若$T(n)$在最好和最坏情况下为$g(n)$和$h(n)$，则可以对$g(n)$和$h(n)$分别做复杂度分析，这一过程中三种记号均可以使用。
![[Pasted image 20240629095322.png]]
然而，不同的记号表达的侧重点不同。如上图所示，当我们使用$O(\cdot)$描述最好情况$g(n)$时，可以体现出“最好”究竟有多好，而使用$\Omega(\cdot)$则无法体现这一点。沿用上述起泡排序的示例，最好情况下$T(n) = n$，$O(n)$表示最好情况的时间复杂度不会比$n$更高，即至少能低到$n$量级，而$\Omega(n)$表示不会比$n$更低，却并不能说明具体有多低，比如$n$和$n^2$均可以表示为$\Omega(n)$。相应的，$\Omega(\cdot)$才能体现“最坏”到底有多坏。

故无法用$\Theta(\cdot)$准确描述时，常用$O(\cdot)$描述最好情况，用$\Omega(\cdot)$描述最坏情况。
## 1.1.3 应用：分析给定函数的时间复杂度
（24真题）分析给定函数`F(int n)`的时间复杂度，函数的定义如下：
```cpp
void F(int n) {  // 假定字宽足够,运算不会溢出，且每次只需常数时间
    for (int i = 1, j = 1; i < n; j <<= 1) {
        i <<= j;
    }
}
```
### 分析每个变量的变化
- $i$和$j$都初始化为$1$。
- 在每次循环中，$j$左移$1$位，即$j = j * 2$。
- 在每次循环中，$i$左移$j$位，即 $i = i * 2^j$。
### 每次循环结束后$i, j$的变化

|   循环次数   |             $i$             |     $j$      |
| :------: | :-------------------------: | :----------: |
|   $0$    |             $1$             |     $1$      |
|   $1$    |     $1 << 1 = 2 = 2^1$      | $1 << 1 = 2$ |
|   $2$    |     $2 << 2 = 8 = 2^3$      | $2 << 1 = 4$ |
|   $3$    | $8 << 4 = 2 ^{3 + 4} = 2^7$ | $4 << 1 = 8$ |
| $\vdots$ |          $\vdots$           |   $\vdots$   |
|   $k$    |       $2 ^ {2^k - 1}$       |    $2^k$     |

### 循环终止条件
循环继续执行直到$i >= n$，此时我们需要找到$k$，使得$i$达到或超过$n$，即：$n \leq 2^{2^k}$。

两边同时取对数，有：$\log_2(n) \leq 2^k$。

再取对数：$\log_2(\log_2(n)) \leq k$。
### 时间复杂度
循环运行的次数是$k = O(\log_2(\log_2(n)))$，且由于每次循环中的操作（左移和比较）都花费常数时间，因此整个函数`F(int n)`的时间复杂度是：$O(\log(\log(n)))$。
## 1.1.4 应用：比较不同时间复杂度的大小（层次级别）
### 多重对数函数$lg^{*}n$
**前置知识**：$\lg^{(i)}n$表示连续对$n$应用$i$次对数函数，$\lg^{i}n=(\lg n)^i$表示$n$的对数的$i$次幂。

则定义$\lg^{*}n = min \{ i \geq 0 : \lg^{(i)}n \leq 1\}$，即对$n$连续应用对数函数，使其结果$\leq 1$的次数。其增长速度极其缓慢（一般来说，对数函数的底数为$2$）：

$$
\begin{align}
\lg^{*}2 & = 1 \\
\lg^{*}4 & = 2 \\
\lg^{*}16 & = 3 \\
\lg^{*}65535 & = \lg^{*}(2^{16}) = 4 \\
\lg^{*}(2^{65535}) & = 5
\end{align}
$$
显而易见，很少存在一个使$\lg^{*}n > 5$的输入规模。
### 斯特林近似公式
对于阶乘$n!$，一个很明显的弱上界是$n^{n}$，即$n! \leq n^{n}$。而斯特林近似公式给出：
$$
n! = \sqrt{2 \pi n} \left(\frac{n}{e}\right)^{n} \left(1 + \Theta\left(\frac{1}{n}\right)\right) \approx \sqrt{2 \pi n}\left(\frac{n}{e}\right)^{n}
$$
---
**简单应用**：证明$lg(n!) = \Theta(nlgn)$
证明$\Theta(\cdot)$，需要证明$\Omega(\cdot) = O(\cdot)$，即上下界相等。上界较易证明：
$$
\lg(n!) < \lg(n^{n}) = n\lg n
$$
但是下界不好得到，转而使用斯特林近似公式：
$$
\begin{align}
\lg(n!) & = \lg\sqrt{2 \pi n} + n\lg\left(\frac{n}{e}\right) + \lg\left(1 + \Theta\left(\frac{1}{n}\right)\right) \\
& = \frac{1}{2}\lg(2 \pi n) + n(\lg n - \lg e) + \lg\left(1 + \frac{c}{n}\right) , c\text{为常数}\\
& = \Theta(\lg n) + \Theta(n\lg n) + \lg(n + c) - \lg n \\
& = \Theta(n\lg n)
\end{align}
$$
### PPT第40页的证明
![[Pasted image 20240731213127.png|400]]
#### (1) $\text{fib(n)} = O(2^n)$正确
斐波那契数的定义为：$\text{fib(0) = 0, fib(1) = 1, fib(n) = fib(n - 1) + fib(n - 2), n} \geq 2$。

假设$\text{fib(n)} = O(2^n)$，则存在常数$C$，使$\text{fib(n)} \leq C \cdot 2^n$。

首先，对于$n = 0$，$\text{fib(0)} = 0 \leq 1 \cdot 2^0 = 1$。对于$n = 1$，$\text{fib(1)} = 1 \leq 1 \cdot 2^1 = 2$，可以考虑使用数学归纳法。

假设对于所有$k \leq n$，有$\text{fib(k)} \leq 2^k$，则需要证明对于$\text{k = n + 1，fib(n + 1)} \leq 2^{n + 1}$。

由假设可以得知，$\text{fib(n)} \leq 2^n$，$\text{fib(n - 1)} \leq 2^{n - 1}$，则：
$$
\text{fib(n + 1) = fib(n) + fib(n - 1)} \leq 2^n + 2^{n - 1} \leq 2^{n + 1}
$$
故可以得知，对于$n \geq 0$，有$\text{fib(n)} \leq 2^n$，即$\text{fib(n)} = O(2^n)$。
#### (2) $\text{12n + 5} = O(n\log n)$正确
很明显，在$n$足够大时，$12 << \log n$，故$12n < n\log n$，即$\text{12n + 5} = O(n\log n)$。
#### (3) $\log^2(n^{1024} - 2n^6 + 101) = O(?)$
左边等式中，括号内可以等效为$n^{1024}$，则等式左边可以化为：
$$
\log^2(n^{1024}) = (\log n^{1024})^2 = 1024^2\log^2n = O(\log^2n)
$$
#### (4) $\log^dn = O(n^c), \forall c > 0, d > 1$正确
根据洛必达法则：
$$
\lim_{n \rightarrow \infty} \frac{\log^dn}{n^c} = \lim_{n \rightarrow \infty} \frac{d \log^{d - 1}n}{c n^c} = \dots = \lim_{n \rightarrow \infty} \frac{d(d - 1) \cdots 1}{c (c - 1) \cdots (c - d + 1)n^c} = 0
$$
故$n$足够大时，$\log^dn < n^c$，即$\log^dn = O(n^c)$。
#### (5) $\log^{1.001}n = O(\log(n^{1001}))$错误
根据洛必达法则：
$$
\lim_{n \rightarrow \infty} \frac{\log^{1.001}n}{1001\log n} = \lim_{n \rightarrow \infty} \frac{1.001\log^{0.001}n \cdot \frac{1}{n}}{1001\frac{1}{n}} = \lim_{n \rightarrow \infty} \frac{\log^{0.001}n}{1000} = \infty
$$
故$n$足够大时，$\log(n^{1001}) < \log^{1.001}n$，即$\log^{1.001}n = \Omega(\log(n^{1001}))$。

从另一个角度理解，$\log(n^{1001}) = 1001 \log n$是关于$\log n$的线性函数，$\log^{1.001}n$是关于$\log n$的幂函数，增长速度略快于线性，故$\log^{1.001}n = O(\log(n^{1001}))$错误。
#### (6) $(n^2 + 1) / (2n + 3) = O(n)$正确
当$n$足够大时，$(n^2 + 1)/(2n + 3) \approx n / 2 = O(n)$。
#### (7) $n^{2013} = O(n!)$正确
当$n$足够大时，$n! = 1 \cdot 2 \cdots (n - 1) \cdot n > \underbrace{2 \cdot 2 \cdots 2}_{\text{n个}} = 2^n > n^c, \forall c > 0$，故$n^{2013} = O(n!)$。
#### (8) $n! = O(n^{2019})$错误
同(7)。
#### (9) $2^n = O(n!)$正确
同(7)。
### 算法导论思考题3-3
![[Pasted image 20240806220222.png]]
先按照基本层次级别进行划分：
> [!NOTE] 基本层次级别
> **常数**：$1$
> 
> **多重对数函数**：$\lg^*n$，$\lg^*(\lg n)$
> > $\lg^*(\lg n) = \lg^*n - 1$
> 
> **对数函数**：$\ln n$，$\lg^2 n$，$\sqrt{\lg n}$
> 
> **幂函数**：$n^2$，$n^3$，$n$
> 
> **指数函数**：$\left(\frac{3}{2}\right)^n$，$\text{e}^n$，$2^n$
> 
> **阶乘**：$n!$，$(n+1)!$
> 
> **对数函数的对数函数**：$2^{2^n}$，$2^{2^{n+1}}$
> > 如何比较$2^{2^n}$和$(n+1)!$——对两边同时取复合对数$\lg\lg(\cdot)$
> > 
> > $\lg \lg (2^{2^n}) = \lg 2^n = n$
> > 
> > $\lg \lg (n+1)! < \lg \lg (n+1)^{n+1} = \lg [(n + 1) \lg (n + 1)] = \lg(n + 1) + \lg \lg(n + 1) < 2 \lg(n + 1)$
> > 
> > 当$n$足够大时，$2 \lg(n + 1) < n$，且复合对数函数$\lg \lg (x)$单调递增，故$(n + 1)! < 2^{2^n}$

接下来对剩余函数进行逐一分析：
- $\lg(\lg^*n)$即对$\lg^*n$再取一次对数，介于常数与多重对数函数之间。
- $2^{\lg^*n} < 2^{\lg n} = n$，故只需要比较$2^{\lg^*n}$与$\ln n$：
	- 同时取对数，$\lg(2^{\lg^*n}) = \lg^*n < \lg(\ln n)$，故$2^{\lg^*n} < \ln n$，介于多重对数函数和对数函数之间。
- $(\sqrt{2})^{\lg n} = 2^{\frac{1}{2}\lg n} = n^{\frac{1}{2}} = \sqrt{n}$，属于幂函数级别。
- $(\lg n)!$很明显高于对数函数，故只需要比较$(\lg n)!$和$n$：
	- 同时取对数，根据斯特林公式，$\lg n < \lg((\lg n)!) \approx \lg n \lg \lg n < n$，即$n < (\lg n)! < 2^n$，故$(\lg n)!$介于幂函数和指数函数之间。
- $\lg(n!) \approx n\lg n$，介于$n$和$n^2$之间，属于幂函数级别。
- $n^{\frac{1}{\lg n}}$似乎不好直接判断：
	- 取对数可得$\lg(n^{\frac{1}{\lg n}}) = 1$，属于常数级别，默认对数函数以$2$为底的前提下，$n^{\frac{1}{\lg n}} = 2$。
	- 同样的，通过幂指函数变形，$n^{\frac{1}{\lg n}} = 2^{\lg n \frac{1}{\lg n}} = 2$，可以得到相同的结论。
- $\ln \ln n$很明显介于多重对数函数和对数函数之间：
	- 比较$2^{\lg^*n}$与$\ln \ln n$，同时取对数，$\lg(2^{\lg^*n}) = \lg^*n < \lg(\ln \ln n)$，故$2^{\lg^*n} < \ln \ln n$。
- $n \cdot 2^n$介于$2^n$与$\text{e}^n$之间。
- $n^{\lg \lg n} = 2^{\lg n \lg \lg n} = (\lg n)^{\lg n}$介于幂函数和指数函数之间：
	- 比较$(\lg n)^{\lg n}$和$(\lg n)!$，直接取对数，$\lg((\lg n)^{\lg n}) = \lg n \lg \lg n$，根据斯特林公式，$\lg((\lg n)!) \approx \lg n \lg \lg n = \Theta(\lg((\lg n)^{\lg n})$，无法判断：
		- 若两个函数分别取对数后同阶，则两个函数本身并**不一定**同阶，如$n^2$和$n^3$，取对数后$\lg n^2 = 2\lg n = \Theta(\lg n) = 3\lg n = \lg n^3$，但$n^2 \neq \Theta(n^3)$。
		- 也就是说，取对数只能判断哪个阶数更高，不能判断是否同阶。
	- 对原始函数应用斯特林公式，$(\lg n)! \approx \sqrt{\lg n} \left(\frac{\lg n}{e}\right)^{\lg n} = \frac{\sqrt{\lg n}}{n} (\lg n)^{\lg n} < (\lg n)^{\lg n}$。
- $2^{\lg n} = n$，属于幂函数级别。
- $4^{\lg n} = (2^{\lg n})^2 = n^2$，属于幂函数级别。
- $2^{\sqrt{2\lg n}} = 2^{\lg n \sqrt{\frac{2}{\lg n}}} = n^{\sqrt{\frac{2}{\lg n}}}$，低于幂函数级别：****
	- 比较$2^{\sqrt{2\lg n}}$和$\lg^2n$，同时取对数$\lg 2^{\sqrt{2\lg n}} = \sqrt{2\lg n} \lg 2$，$\lg(\lg^2n) = 2 \lg \lg n < \sqrt{2}\lg2 \sqrt{\lg n}$，故$\lg^2 n < 2^{\sqrt{2 \lg n}} < n$。

综上所述，可以得到排序如下：
![[Pasted image 20240808152628.png]]


