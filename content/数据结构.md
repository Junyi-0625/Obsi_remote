# 1 绪论
## 1.1 复杂度
### 1.1.1 定义
当输入数据规模为$n$时，算法执行时间的变化趋势可以表示为一个关于$n$的函数，即时间复杂度$T(n)$。当$n \rightarrow \infty$时，有三种情况：
1. $T(n) \leq C \cdot f(n)$，且$C>0$为常数，则$T(n) = O(f(n))$；
2. $C_1 \cdot h(n) \leq T(n) \leq C_2 \cdot h(n)$，且$C_2 > C_1 > 0$为常数，则$T(n) = \Theta(h(n))$；
3. $C \cdot g(n) \leq T(n)$，且$C > 0$为常数，则$T(n) = \Omega(g(n))$。
这种注重时间复杂度总体变化趋势的，用$O(\cdot)$、$\Theta(\cdot)$和$\Omega(\cdot)$表示的记号称为**渐进复杂度**。
其中，$f(n)$为$T(n)$的渐进上界，$g(n)$为$T(n)$的渐进下界，$h(n)$为$T(n)$的确界。
在“$n$充分大”和“忽略常数”的前提下，易知：
$O(f(n)) = O(c \cdot f(n)), c > 0$，且$O(n^a + n^b) = O(n^a), a > b > 0$。
### 1.1.2 性质
**一、不可交换**
例：设$n^3 = O(n^4)$，$n^2 = O(n^4)$，但$n^3 = o(n^4) = n^2$并不成立。即复杂度记号中的“=”两边不可交换。有以下三个性质：
1. **等式左边包含的信息不少于右边**（最基本的性质）；
2. 复杂度记号本身损失了常数信息，故只能出现在等式右侧。若出现在左侧，则右侧也一定是复杂度记号；
3. 从$\Theta(\cdot)$转化为$O(\cdot)$或者$\Omega(\cdot)$会损失一侧的信息，故连等式中$\Theta(\cdot)$只会出现在等式左侧。只有一种情况例外，即$O(1) = \Theta(1)$。
如，$2n^2 = \Theta(n^2) = O(n^3) = O(n^4)$正确。
**二、不是所有算法都可以用$\Theta(\cdot)$衡量**
例：$T(n) = n (\sin(\frac{n \pi}{2}) + 1)$不存在与其同阶的无穷大量。所以我们更多的使用表示上界的$O(\cdot)$来描述增长速度。
**三、只有$\Theta(\cdot)$才能进行比较**
例：已知算法A的时间复杂度为$O(n)$，算法B的时间复杂度为$O(n^2)$，是否能认为算法A的时间复杂度一定低于算法B？
无从得知，$O(\cdot)$仅表示上界，无算法B的时间复杂度同时也可能是$O(n)$甚至$O(1)$。
类似的，$\Omega(\cdot)$也不可比较，只有表示同阶无穷大量的$\Theta(\cdot)$有比较的意义。
**四、不满足除法，仅满足单向乘法**
$O(f(n)) / O(g(n)) = O(f(n) / g(n))$不成立。
$O(f(n)) \cdot O(g(n)) = O(f(n) \cdot g(n))$成立，但反过来则不成立。
复杂度记号包裹的范围越大，就会损失越多的信息。
**五、复杂度记号与情况无关**
尽管$O(\cdot)$和$\Omega(\cdot)$表示上下界，但并不代表“最坏情况”和“最好情况”。
**情况**表示和输入数据规模$n$无关的数据特征。比如使用起泡排序`bubblesort1A()`进行排序。
```C++
void bubblesort1A(int A[], int n){
	bool sorted = false;
	while(!sorted){
		sorted = true;
		for(int i = 1; i < n; i++){
			if(A[i - 1] > A[i]){
				swap(A[i - 1], A[i]); //交换逆序的A[i - 1]和A[i]
				sorted = false;
			}
		}
		n--; //每扫描完一趟，末尾元素必然就位
	}
}
```
![[Pasted image 20240628223046.png]]
除了问题规模$n$之外，这$n$个整数自身的排列特征也会影响排序的时间。若所有元素已按序排列，则内循环仅需要一趟便可终止算法，即$T(n) = n$。若$n$个元素完全逆序，即输入序列为{n, n - 1, ..., 1}，则每个元素均需要进行$n - 1$次交换，可认为$T(n) = n(n - 1)$。
对于同样的$n$，不同情况的输入数据会得到不同的$T(n)$，即$T(n)$从一个准确的值变成了一个范围，其下限对应最好情况，上限对应最坏情况。若$T(n)$在最好和最坏情况下为$g(n)$和$h(n)$，则可以对$g(n)$和$h(n)$分别做复杂度分析，这一过程中三种记号均可以使用。
![[Pasted image 20240629095322.png]]
然而，不同的记号表达的侧重点不同。如上图所示，当我们使用$O(\cdot)$描述最好情况$g(n)$时，可以体现出“最好”究竟有多好，而使用$\Omega(\cdot)$则无法体现这一点。沿用上述起泡排序的示例，最好情况下$T(n) = n$，$O(n)$表示最好情况的时间复杂度不会比$n$更高，即至少能低到$n$量级，而$\Omega(n)$表示不会比$n$更低，却并不能说明具体有多低。相应的，$\Omega(\cdot)$才能体现“最坏”到底有多坏。
故无法用$\Theta(\cdot)$准确描述时，常用$O(\cdot)$描述最好情况，用$\Omega(\cdot)$描述最坏情况。

